#!/usr/bin/env hy

(import os)
(import sys)
(import random)

(require hy.contrib.loop)

(import [autotracker [generate MIDDLE_C samples]])
(import [autotracker.it.sample [Sample_File Sample_FileSlice Sample_KS]])
(import [autotracker.keys [Key_Minor Key_Major]])
(import [autotracker.strategies [Strategy_Main]])
(import [autotracker.generators [Generator_Bass Generator_ProbabilityTable Generator_Callback Generator_AmbientMelody Generator_Breaks]])

(def here (os.path.dirname __file__))

(defn get-random-bleep [t]
  (os.path.join samples (random.choice (list-comp f [f (os.listdir samples)] (and (f.startswith "c64") (in (+ "-" t ".wav") f))))))

(defn get-random-sample [subfolder n]
  (os.path.join samples subfolder (random.choice (list-comp f [f (os.listdir (os.path.join samples subfolder))] (and (f.startswith n) (f.endswith ".wav"))))))

(defn fx [c] (- (ord c) 96))

(defn get-wrapped [array index]
  (get array (% (int index) (len array))))

(defn dir-to-samples [d itf] (list-comp
                               (itf.smp_add (Sample_File :name (os.path.basename f) :filename (os.path.join d f)))
                               [f (os.listdir d)]
                               (f.endswith ".wav")))

; from CanOfBeats
(def bd-prob [1 0.1 0.9 0.1  0.05 0.1 0.01 0.1  0.8 0.1 0.7 0.1  0.05 0.01 0.01 0.2])
(def sd-prob [0 0.05 0.05 0.05  0.95 0 0 0.2 0 0.05 0 0  0.95 0 0 0.1])
(def hh-prob [0.95 0.05 0.95 0.05  0.95 0.1 0.95 0.1   0.95 0.05 0.95 0.05  0.95 0.05 0.95 0.05])

(defn totally-random-prob [] (list-comp (pow (random.random) 2) [p (xrange 16)]))

(defn hat-probability [tick]
  (get [0.95 0.05 0.1 0.05] (% tick 4)))

; TODO: compute trill mask and use it
(defn make-hats-fn [hat-samples]
  (let [[trill-mask (list-comp x [x (range 16)])]])
  (fn [channel-number pattern strategy rhythm beat-begin beats-length key-root key-chord]
    (for [row (xrange beat-begin (+ beat-begin beats-length))]
      (let [[prob (hat-probability row)]
            [sample (if (> (random.random) 0.9) (random.choice hat-samples) (get hat-samples 0))]
            [pitch 60]
            [volume (get [255 127 255 127] (% row 4))]]
        (when (< (random.random) prob)
          (setv (get (get pattern.data row) channel-number) 
            [pitch sample volume 0 0]))))))

(defn make-fractal-sequence [sequence-length number-of-notes &optional [basic-sequence-length 4] [sparseness-probability 0.75]]
 (let [[basic-sequence (random.sample (range number-of-notes) basic-sequence-length)]]
    (list-comp
      (if (> (random.random) sparseness-probability)
        nil
        (get basic-sequence (% (int (/ t (random.choice [1 2 4]))) (len basic-sequence))))
      [t (xrange sequence-length)])))

; TODO: specify note length
(defn make-melody-fn [sample root-note sequence notes-set pace &optional [volume 255]]
  (fn [channel-number pattern strategy rhythm beat-begin beats-length key-root key-chord]
    ; (print strategy.pat_idx)
    (for [row (xrange beat-begin (+ beat-begin beats-length) pace)]
      (let [[note (get sequence (% (int (/ row pace)) (len sequence)))]]
        (when (not (or (= note nil) (= (get notes-set note) nil)))
          (setv (get (get pattern.data row) channel-number)
            [(+ (get notes-set note) root-note) sample volume 0 0]))))))

; TODO: two kinds of break rhythm
; TODO: break repeats, break fills
(defn make-breaks-fn [sample-chunks-break sample-bassdrum sample-snaredrum &optional [break-pitch 60]]
  (let [[break-loop (list-comp x [x (range 16)])]
        [break-pace 8]
        [beat-pace 4]
        [bass-snare-rhythm (random.choice [[1 0 2 0  0 1 2 0]
                                           [0 1 2 0  1 0 2 0]
                                           [1 0 0 1  0 0 2 0]
                                           [1 0 2 1  0 2 0 0]])]]
    (fn [channel-number pattern strategy rhythm beat-begin beats-length key-root key-chord]
      (for [row (xrange beat-begin (+ beat-begin beats-length))]
        ; lay down the breakbeat
        (if (= (% row break-pace) 0)
        (setv (get (get pattern.data row) channel-number)
          [break-pitch (get-wrapped sample-chunks-break (/ row break-pace)) 255 0 0]))
        ; lay down the back-beat
        (if (= (% row beat-pace) 0)
          (let [[which-drum (get-wrapped bass-snare-rhythm (/ row beat-pace))]]
            (if (> which-drum 0)
              (setv (get (get pattern.data row) (+ channel-number 1))
                [60 (get [sample-bassdrum sample-snaredrum] (- which-drum 1)) 255 0 0]))))))))

; eyeballed
(def note-jump-probabilities [5 5 5 5 5 7 7 7 3 3 3 2 2 4 4 1])

(defn get-good-notes [n]
  ; (random.sample (range 0 12) (+ (max sequence) 1))
  (loop [[c (dec n)] [notes [(random.randint 0 12)]]]
    (if (> c 0)
      (recur
        (dec c)
        (+ notes [(% (+ (get notes -1) (random.choice note-jump-probabilities)) 12)]))
      (sorted notes))))

(defn transform-notes [notes]
  (let [[pivot (random.randint 0 12)]]
    (list-comp (% (+ (* (- n pivot) -1) pivot) 12) [n notes])))

(defn make-section-lookup-fn [section-fns sections-pattern]
  (fn [channel-number pattern strategy &rest args]
    (apply (get section-fns (get-wrapped sections-pattern strategy.pat_idx)) (+ [channel-number pattern strategy] (list args)))))

(generate
  sys.argv
  (fn [itf]
    (setv itf.tempo (random.randint 165 185))
    (print itf.tempo "BPM")
    (let [[sample-hi-bleep (itf.smp_add (Sample_File :name "hi-bleep" :filename (get-random-bleep "hi")))]
          [sample-lo-bleep (itf.smp_add (Sample_File :name "lo-bleep" :filename (get-random-bleep "lo")))]
          [sample-bass (itf.smp_add (Sample_KS :name "bass" :freq (/ MIDDLE_C 4) :decay 0.005 :nfrqmul 0.5 :filt0 0.2 :filtn 0.2 :filtf 0.005 :length_sec 0.7))]
          ;[sample-808-bassdrum (itf.smp_add (Sample_File :name "808-bassdrum" :filename (get-random-sample "808" "bass")))]
          ;[sample-808-snaredrum (itf.smp_add (Sample_File :name "808-snare" :filename (get-random-sample "808" "snare")))]
          [sample-bassdrum (itf.smp_add (Sample_File :name "bassdrum" :filename (get-random-sample "CanOfBeats" "bd")))]
          [sample-snaredrum (itf.smp_add (Sample_File :name "snaredrum" :filename (get-random-sample "CanOfBeats" "sd")))]
          [sample-break (random.choice ["amen.wav" "think.wav"])]
          [sample-chunks-break (list-comp (itf.smp_add (Sample_FileSlice :filename (os.path.join samples sample-break) :slices 4 :which s)) [s (range 4)])]
          ;[samples-808-hihat (list-comp (itf.smp_add (Sample_File :name (+ "808-hihat-" (unicode b)) :filename (get-random-sample "808" "hi hat-snappy"))) [b (xrange 3)])]
          [samples-sfxrs (dir-to-samples (os.path.join here "samples") itf)]
          ; compute a two basic sequences of notes using the fractal melody method
          [sequences (list-comp (make-fractal-sequence (random.choice [16 32]) 4 :sparseness-probability (+ (* (random.random) 0.5) 0.25)) [x (range 2)])]
          ; bass variation
          [sequence-bass (slice (list (reversed (get sequences 0))) 0 16)]
          ; select some notes randomly to map to the sequence
          [notes-set (get-good-notes 4)]
          [notes-set-alt (transform-notes notes-set)]
          
          [melody-fns-main [(make-melody-fn sample-hi-bleep 60 (get sequences 0) notes-set 4 :volume 230)
                            (make-melody-fn sample-hi-bleep 60 (get sequences 1) notes-set-alt 4 :volume 230)]]
          [melody-fns-bass [(make-melody-fn sample-lo-bleep 60 sequence-bass notes-set 8)
                           (make-melody-fn sample-lo-bleep 60 sequence-bass notes-set-alt 8)]]
          [master-key (if (< (random.random) 0.6) Key_Minor Key_Major)]
          [root (+ 12 (random.randint 50 (+ 50 12 -1)))]
          [strategy (Strategy_Main root master-key 128 32)]]
      ;(strategy.gen_add (Generator_ProbabilityTable sample-808-bassdrum :probability-table bd-prob))
      ;(strategy.gen_add (Generator_ProbabilityTable sample-808-snaredrum :probability-table sd-prob))
      ;(strategy.gen_add (Generator_Callback 1 (make-hats-fn samples-hihat)))

      ; (strategy.gen_add (Generator_Callback 2 (make-breaks-fn sample-chunks-break sample-bassdrum sample-snaredrum :break-pitch (+ 59 (int (/ (- itf.tempo 165) 4))))))
      (strategy.gen_add (Generator_Callback 1 (make-section-lookup-fn melody-fns-main [0 0 0 0 1 1 1 1])))
      (strategy.gen_add (Generator_Callback 1 (make-section-lookup-fn melody-fns-bass [0 0 0 0 1 1 1 1])))

      ;(strategy.gen_add (Generator_Breaks :s_chunks sample-chunks-break :pitch (+ 59 (int (/ (- itf.tempo 165) 4)))))
      ;(strategy.gen_add (Generator_Callback 1 (make-melody-fn sample-bleep 84 sequence-meta-melody notes-set-bass 1)))
      ;(strategy.gen_add (Generator_Callback 1 (make-melody-fn sample-bleep 48 sequence-bass notes-set-bass 8)))
      ;(strategy.gen_add (Generator_Callback 1 (make-melody-fn sample-lo-bleep 84 sequence-meta-melody notes-set-bass 1)))
      ;(strategy.gen_add (Generator_Bass :smp sample-bass))
      ;(for [s sfxrs]
      ;  (strategy.gen_add (Generator_ProbabilityTable s :probability-table (random.choice [(totally-random-prob) bd-prob sd-prob]))))
      (for [i (xrange 8)]
        (print "pattern" i)
        (itf.ord_add (itf.pat_add (strategy.get_pattern))))
      itf)))

